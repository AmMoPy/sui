import{elements}from"./elements.min.js";import{state,saveState}from"./state.min.js";import{getDB,debugDB}from"./database.min.js";import{MAX_FILE_SIZE,COMPRESSION_THRESHOLD,ALLOWED_AUDIO_TYPES,FILE_SIZE_LIMITS,CONVERSION_PRESETS,CONVERSION_OPTIONS,AUDIO_SIGNATURES}from"./constants.min.js";import{showStatusMessage,renderPlayList,speakText}from"./ui.min.js";import{loadItem}from"./playback.min.js";async function handleFileUpload(e){const files=Array.from(e.target.files);if(!files.length)return;e.target.value="";const totalSize=files.reduce(((total,file)=>total+file.size),0);const totalFiles=files.length;if(totalSize>100*1024*1024||totalFiles>50){const proceed=confirm(`You're uploading ${totalFiles} files (${formatFileSize(totalSize)}). `+`Large uploads may cause performance issues. Continue?`);if(!proceed)return}const BATCH_SIZE=5;for(let i=0;i<files.length;i+=BATCH_SIZE){const batch=files.slice(i,i+BATCH_SIZE);await Promise.all(batch.map((async file=>{try{await processFile(file)}catch(error){console.error(`Processing failed for ${file.name}:`,error);uploadManager.updateProgress(file,0,`Error: ${error.message}`);showStatusMessage(`Failed to process ${file.name}: ${error.message}`,"error")}})));if(i+BATCH_SIZE<files.length){await new Promise((resolve=>setTimeout(resolve,300)))}}await loadItems(false)}async function loadItems(autoplay=false){if(state.currentAudioUrl){URL.revokeObjectURL(state.currentAudioUrl);state.currentAudioUrl=null}try{const database=await getDB();const tx=database.transaction("items","readonly");const store=tx.objectStore("items");const allItems=await new Promise(((resolve,reject)=>{const req=store.getAll();req.onsuccess=()=>resolve(req.result);req.onerror=()=>reject(req.error)}));const sortedItems=sortItems(allItems,state.sortPreferences);state.items=sortedItems;const hasDefaultItems=allItems.some((item=>item.type==="default"));if(!hasDefaultItems&&!state.defaultsDeleted&&!state.defaultsInitialized){try{const defaultItems=[{name:"1",path:"assets/main/better_day.mp3",type:"default"},{name:"2",path:"assets/main/care.mp3",type:"default"}];const addTx=database.transaction("items","readwrite");const addStore=addTx.objectStore("items");for(const item of defaultItems){addStore.add(item)}await new Promise(((resolve,reject)=>{addTx.oncomplete=()=>{state.defaultsInitialized=true;saveState();resolve()};addTx.onerror=()=>reject(addTx.error)}));const newTx=database.transaction("items","readonly");const newStore=newTx.objectStore("items");const updatedItems=await new Promise(((resolve,reject)=>{const req=newStore.getAll();req.onsuccess=()=>resolve(req.result);req.onerror=()=>reject(req.error)}));state.items=updatedItems}catch(error){console.error("Failed to add default items:",error)}}else if(hasDefaultItems){state.defaultsInitialized=true;saveState()}renderPlayList();if(state.items.length>0){const prevIndex=state.currentIndex;if(state.currentIndex>=state.items.length){state.currentIndex=state.items.length-1}if(autoplay){loadItem(state.currentIndex)}else{const item=state.items[state.currentIndex];if(item){if(item.path){state.audio.src=item.path}else if(item.data){const blob=new Blob([item.data],{type:"audio/mp3"});state.currentAudioUrl=URL.createObjectURL(blob);state.audio.src=state.currentAudioUrl}}}}else{state.audio.pause();state.audio.removeAttribute("src");state.audio.load();elements.playPauseBtn.textContent="▶";console.log("No items in playlist");speakText("Empty")}}catch(error){console.error("Error loading playlist items:",error);showStatusMessage("Failed to load playlist","error")}}function sortItems(items,preferences){const{field:field,direction:direction}=preferences;return items.sort(((a,b)=>{const valueA=a[field]||0;const valueB=b[field]||0;return direction==="asc"?valueA-valueB:valueB-valueA}))}class UploadManager{constructor(){this.progressBars=new Map;this.activeConversions=new Set;this.hasFFmpeg=false;this.basePath="js/ffmpeg";this.ffmpegLoading=false;this.ffmpegLoadPromise=null;this.pendingUploads=[];this.ffmpeg=null;this.initFFmpeg()}async initFFmpeg(){if(this.ffmpegLoading){return this.ffmpegLoadPromise}this.ffmpegLoading=true;this.ffmpegLoadPromise=new Promise((async resolve=>{try{const{FFmpeg:FFmpeg}=window.FFmpegWASM;this.ffmpeg=new FFmpeg;this.ffmpeg.on("progress",(({progress:progress,time:time})=>{if(progress<=1){console.log(`FFmpeg progress: ${Math.floor(progress*100)}%`);this.showFFmpegLoadingStatus(progress)}else{console.log(`FFmpeg processing: stream reading phase`);this.showFFmpegLoadingStatus(-1)}}));this.ffmpeg.on("log",(({message:message})=>{console.log(`FFmpeg log: ${message}`)}));await this.ffmpeg.load({coreURL:`${this.basePath}/ffmpeg-core.js?v=0.12.10`,wasmURL:`${this.basePath}/ffmpeg-core.wasm?v=0.12.10`});console.log("FFmpeg ready!");this.hasFFmpeg=true;this.processPendingUploads();resolve(true)}catch(err){console.error("FFmpeg initialization failed:",err);this.hasFFmpeg=false;resolve(false)}finally{this.ffmpegLoading=false}}));return this.ffmpegLoadPromise}showFFmpegLoadingStatus(progress){let statusEl=document.getElementById("ffmpeg-status");if(!statusEl){statusEl=document.createElement("div");statusEl.id="ffmpeg-status";statusEl.className="ffmpeg-status";statusEl.innerHTML='<span class="label">File Processing Progress</span> <span class="progress">0%</span>';const container=elements.uploadProgressContainer||document.body;container.appendChild(statusEl)}const progressEl=statusEl.querySelector(".progress");if(progressEl){if(progress>=0){statusEl.classList.remove("indeterminate");progressEl.textContent=`${Math.floor(progress*100)}%`}else{statusEl.classList.add("indeterminate");progressEl.textContent=`Analyzing...`}}if(progress>=1){setTimeout((()=>{statusEl.remove()}),2e3)}}async processPendingUploads(){if(this.pendingUploads.length===0)return;console.log(`Processing ${this.pendingUploads.length} pending uploads now that FFmpeg is ready`);const activeUploads=this.pendingUploads.filter((p=>p.active));console.log(`${activeUploads.length} active uploads to process`);const uploads=[...activeUploads];this.pendingUploads=this.pendingUploads.filter((p=>!p.active));for(const pendingUpload of uploads){try{if(pendingUpload.active){await processFile(pendingUpload.file);await loadItems(false)}}catch(error){console.error(`Error processing pending upload ${pendingUpload.file.name}:`,error)}}}addPendingUpload(file){const pendingUpload={file:file,active:true};this.pendingUploads.push(pendingUpload);return pendingUpload}createProgressUI(file){const wrapper=document.createElement("div");wrapper.className="upload-item";wrapper.innerHTML=`\n      <div class="file-info">\n        <span class="filename">${file.name}</span>\n        <span class="filesize">${formatFileSize(file.size)}</span>\n      </div>\n      <div class="progress-container">\n        <progress value="0" max="100"></progress>\n        <span class="status">Waiting...</span>\n      </div>\n      <div class="conversion-info hidden"></div>\n      <button class="cancel-btn"><span>✕</span></button>\n    `;elements.uploadProgressContainer.appendChild(wrapper);const cancelBtn=wrapper.querySelector(".cancel-btn");cancelBtn.addEventListener("click",(()=>{this.cancelOperation(file.name);wrapper.classList.add("cancelled");wrapper.querySelector(".status").textContent="Cancelled";setTimeout((()=>{wrapper.remove();this.progressBars.delete(file.name)}),1e3)}));return wrapper}async cancelOperation(fileName){console.log(`Cancelling operation for ${fileName}`);const pendingUpload=this.pendingUploads.find((p=>p.file.name===fileName));if(pendingUpload){pendingUpload.active=false;console.log(`Marked pending upload ${fileName} as inactive`)}if(this.ffmpeg&&this.activeConversions.has(fileName)){try{const statusEl=document.getElementById("ffmpeg-status");if(statusEl){statusEl.remove()}await this.ffmpeg.terminate();this.activeConversions.clear();console.log("FFmpeg process terminated successfully");this.hasFFmpeg=false;this.ffmpegLoading=false;this.initFFmpeg().then((()=>{console.log("FFmpeg re-initialized after cancellation");this.processPendingUploads()}))}catch(error){console.error("Error terminating FFmpeg:",error)}}const wrapper=this.progressBars.get(fileName);if(wrapper){wrapper.classList.add("cancelled");wrapper.querySelector(".status").textContent="Cancelled";setTimeout((()=>{wrapper.remove();this.progressBars.delete(fileName)}),1e3)}this.activeConversions.delete(fileName)}updateProgress(file,percent,message=""){let wrapper=this.progressBars.get(file.name);if(message==="Cancelled"&&wrapper){wrapper.remove();this.progressBars.delete(file.name);return}if(!wrapper){wrapper=this.createProgressUI(file);this.progressBars.set(file.name,wrapper)}const progressBar=wrapper.querySelector("progress");const statusEl=wrapper.querySelector(".status");progressBar.value=percent;statusEl.textContent=message||`${Math.round(percent)}%`;if(percent>=100){wrapper.classList.add("completed");setTimeout((()=>{wrapper.remove();this.progressBars.delete(file.name)}),3e3)}}canConvert(){return this.hasFFmpeg}isFFmpegLoading(){return this.ffmpegLoading}}const uploadManager=new UploadManager;async function processFile(file){const validation=await validateFile(file);if(!validation.valid){showStatusMessage(validation.message,"error");return}uploadManager.updateProgress(file,0,"Preparing...");let processedFile=file;let originalFile=file;if(validation.suggestCompress||validation.needsConversion){if(uploadManager.isFFmpegLoading()){uploadManager.updateProgress(file,0,"Waiting for audio processor...");const pendingUpload=uploadManager.addPendingUpload(file);return}try{const result=await handleCompressionConversion(file,validation);if(!result){uploadManager.updateProgress(file,0,"Cancelled");return}processedFile=result;console.log(`Compressed ${processedFile.name}: \n        Before: ${formatFileSize(originalFile.size)} \n        After: ${formatFileSize(processedFile.size)}\n        Reduction: ${Math.round((1-processedFile.size/originalFile.size)*100)}%`)}catch(error){console.error("Processing error:",error);uploadManager.updateProgress(file,0,"Processing failed");return}}try{await uploadToDB(processedFile,originalFile)}catch(error){if(error.message==="Operation cancelled by user"){uploadManager.updateProgress(file,0,"Cancelled")}else{uploadManager.updateProgress(file,0,"Upload failed");throw error}}}async function validateFile(file){try{if(!ALLOWED_AUDIO_TYPES.includes(file.type)){console.log(`MIME check failed: ${file.type}`);return{valid:false,message:`${file.name}: Unsupported format`}}const actualType=await getActualFileType(file);if(!actualType||!ALLOWED_AUDIO_TYPES.includes(actualType)){console.log(`Header check failed. Allowed: ${ALLOWED_AUDIO_TYPES.join(", ")}`);return{valid:false,message:`${file.name}: Actual format (${actualType||"unknown"}) not allowed`}}const maxSize=FILE_SIZE_LIMITS[actualType]||FILE_SIZE_LIMITS.default;const isOverMax=file.size>maxSize;const isOverThreshold=file.size>COMPRESSION_THRESHOLD;const needsConversion=["audio/wav","audio/flac","video/mp4","audio/mp4"].includes(actualType);const suggestCompress=isOverThreshold&&!needsConversion;return{valid:!isOverMax,message:isOverMax?`${file.name} exceeds limit (${formatFileSize(maxSize)})`:`${file.name} validated (${formatFileSize(file.size)})`,actualType:actualType,suggestCompress:suggestCompress,needsConversion:needsConversion,originalSize:file.size}}catch(error){console.error("Validation error:",error);return{valid:false,message:`${file.name}: Validation failed - ${error.message}`}}}async function getActualFileType(file){const buffer=await file.slice(0,128).arrayBuffer();const view=new DataView(buffer);if(checkBytes(view,4,AUDIO_SIGNATURES.mp4.bytes)){const majorBrand=String.fromCharCode(view.getUint8(8),view.getUint8(9),view.getUint8(10),view.getUint8(11));if(AUDIO_SIGNATURES.mp4.subtypes.audio.includes(majorBrand)){return"audio/mp4"}if(AUDIO_SIGNATURES.mp4.subtypes.video.includes(majorBrand)){return"video/mp4"}return view.getUint32(20)===1936684398?"audio/mp4":"video/mp4"}for(const[format,{offset:offset,bytes:bytes}]of Object.entries(AUDIO_SIGNATURES)){let match=true;for(let i=0;i<bytes.length;i++){if(view.getUint8(offset+i)!==bytes[i]){match=false;break}}if(match)return`audio/${format}`}if(view.getUint8(0)===255&&(view.getUint8(1)&224)===224){return"audio/mpeg"}return null}function checkBytes(view,offset,bytes){return bytes.every(((b,i)=>view.getUint8(offset+i)===b))}async function handleCompressionConversion(file,validation){const options=await showConversionDialog(file,validation);if(!options?.targetFormat){if(options){uploadManager.updateProgress(file,100,"Keeping original")}return options?file:null}try{const formatLabel=options.targetFormat.split("/")[1].toUpperCase();const actionType=options.targetFormat===validation.actualType?"Compressing":"Converting";uploadManager.updateProgress(file,50,`${actionType} to ${formatLabel}...`);let result;if(uploadManager.canConvert()){result=await convertAudio(file,options.targetFormat)}else{uploadManager.updateProgress(file,50,"Using basic conversion (FFmpeg not available)...");result=await basicCompression(file)}const sizeDifference=validation.originalSize-result.size;const sizeChangePercent=Math.abs(sizeDifference/validation.originalSize*100).toFixed(1);uploadManager.updateProgress(file,100,sizeDifference>0?`Size (↓) ${sizeChangePercent}%`:`Size (↑) ${sizeChangePercent}%`);return result.size<validation.originalSize?result:file}catch(error){if(error.message==="Operation cancelled by user"){uploadManager.updateProgress(file,0,"Cancelled");return null}uploadManager.updateProgress(file,0,`Processing failed: ${error.message}`);throw error}}async function showConversionDialog(file,validation){return new Promise((resolve=>{const dialog=document.createElement("div");dialog.className="conversion-dialog";const options=[];if(validation.needsConversion){options.push(...(CONVERSION_OPTIONS[validation.actualType]||CONVERSION_OPTIONS.default).map((format=>({label:`Convert to ${format.split("/")[1].toUpperCase()}`,action:()=>resolve({targetFormat:format})}))),{label:"Keep original size",action:()=>resolve({})})}else if(validation.suggestCompress){options.push({label:`Compress to smaller file size`,action:()=>resolve({targetFormat:validation.actualType})},{label:"Keep original size",action:()=>resolve({})})}options.push({label:"Cancel upload",action:()=>resolve(null)});dialog.innerHTML=`\n      <div class="dialog-content">\n        <h3>Process ${file.name}?</h3>\n        <p>${validation.needsConversion?"File format not supported directly.":`File is quite large (${formatFileSize(file.size)})`}</p>\n        <div class="countdown-timer">Auto-selecting in <span class="timer">30</span>s</div>\n        <div class="options">\n          ${options.map((opt=>`<button class="option-btn">${opt.label}</button>`)).join("")}\n        </div>\n      </div>\n    `;document.body.appendChild(dialog);options.forEach(((opt,i)=>{dialog.querySelectorAll(".option-btn")[i].addEventListener("click",(()=>{opt.action();dialog.remove()}))}));const timerEl=dialog.querySelector(".timer");let timeLeft=30;const updateTimer=()=>{timerEl.textContent=timeLeft;timeLeft--};const intervalId=setInterval(updateTimer,1e3);const timeoutId=setTimeout((()=>{clearInterval(intervalId);if(options.length>0){options[0].action()}else{resolve(null)}dialog.remove()}),3e4)}))}async function convertAudio(file,targetFormat){if(!uploadManager.canConvert()){throw new Error("FFmpeg not available for conversion")}uploadManager.activeConversions.add(file.name);const inputFileName=`input_${Date.now()}.${file.name.split(".").pop()}`;const outputFile=`output_${Date.now()}.${targetFormat.split("/")[1]}`;try{const ffmpeg=uploadManager.ffmpeg;console.log("Starting conversion process...");uploadManager.updateProgress(file,15,"Preparing audio...");try{const fileData=new Uint8Array(await file.arrayBuffer());console.log(`Writing ${fileData.length} bytes to ${inputFileName}`);await ffmpeg.writeFile(inputFileName,fileData);console.log("File written successfully")}catch(error){if(error.message==="Operation cancelled by user"){throw error}console.error("Error writing file to FFmpeg:",error);throw new Error(`Failed to write file to FFmpeg: ${error.message}`)}uploadManager.updateProgress(file,20,"Analyzing audio...");const optimalBitrate=await getOptimalBitrate(ffmpeg,inputFileName);console.log(`Determined optimal bitrate: ${optimalBitrate}kbps`);if(targetFormat==="audio/mp3"){CONVERSION_PRESETS["audio/mp3"].bitrate=optimalBitrate}uploadManager.updateProgress(file,25,"Converting format...");try{const speedOptimization=["-threads","4","-preset","veryfast"];const ffmpegArgs=["-i",inputFileName,...speedOptimization,...getFFmpegArgs(targetFormat),outputFile];console.log("Running FFmpeg with args:",ffmpegArgs.join(" "));await ffmpeg.exec(ffmpegArgs);console.log("Conversion completed")}catch(error){if(error.message==="Operation cancelled by user"){throw error}console.error("Error during FFmpeg conversion:",error);throw new Error(`FFmpeg conversion failed: ${error.message}`)}let data;try{uploadManager.updateProgress(file,75,"Finalizing...");console.log(`Reading output file: ${outputFile}`);data=await ffmpeg.readFile(outputFile)}catch(error){console.error("Error reading output file:",error);throw new Error(`Failed to read converted file: ${error.message}`)}try{console.log("Cleaning up temporary files");await ffmpeg.deleteFile(inputFileName);await ffmpeg.deleteFile(outputFile)}catch(cleanupError){console.warn("Non-critical error during cleanup:",cleanupError)}return new File([data],`${file.name.replace(/\.[^/.]+$/,"")}.${targetFormat.split("/")[1]}`,{type:targetFormat})}catch(error){console.error("Audio conversion failed:",error);if(error.message==="Operation cancelled by user"){uploadManager.updateProgress(file,0,"Cancelled")}else{uploadManager.updateProgress(file,0,`Failed: ${error.message}`)}uploadManager.updateProgress(file,0,`Failed: ${error.message}`);throw error}finally{uploadManager.activeConversions.delete(file.name);try{const ffmpeg=uploadManager.ffmpeg;if(ffmpeg){await ffmpeg.deleteFile(inputFileName).catch((()=>{}));await ffmpeg.deleteFile(outputFile).catch((()=>{}))}}catch(e){}}}async function getOptimalBitrate(ffmpeg,inputFile){try{const inputFileData=await ffmpeg.readFile(inputFile);const fileSizeKB=Math.floor(inputFileData.length/1024);const duration=await getAudioDurationWithMediaInfo(inputFileData);console.log(`Audio duration: ${duration} seconds`);const estimatedOriginalBitrate=Math.floor(fileSizeKB*8/duration);let targetBitrate;if(estimatedOriginalBitrate<128){targetBitrate=Math.max(96,Math.floor(estimatedOriginalBitrate*.9))}else if(estimatedOriginalBitrate<192){targetBitrate=128}else if(estimatedOriginalBitrate<256){targetBitrate=160}else{targetBitrate=192}const maxBitrate=Math.floor(estimatedOriginalBitrate*.7);if(maxBitrate>64&&targetBitrate>maxBitrate){targetBitrate=maxBitrate}console.log(`Duration: ${duration}s, File size: ${fileSizeKB}KB, Est. original bitrate: ~${estimatedOriginalBitrate}kbps, Target: ${targetBitrate}kbps`);return targetBitrate}catch(error){console.warn("Couldn't determine optimal bitrate:",error);return 128}}async function getAudioDurationWithMediaInfo(fileData){try{const mediainfo=await MediaInfo.mediaInfoFactory({locateFile:(path,prefix)=>{`${prefix}${path}`}});const dataArray=fileData instanceof Uint8Array?fileData:new Uint8Array(fileData);const result=await mediainfo.analyzeData((()=>dataArray.length),((size,offset)=>new Uint8Array(dataArray.buffer||dataArray,offset,Math.min(size,dataArray.length-offset))));if(result&&result.media&&result.media.track){const audioTrack=result.media.track.find((track=>track["@type"]==="Audio"));if(audioTrack&&audioTrack.Duration){return parseFloat(audioTrack.Duration)}const generalTrack=result.media.track.find((track=>track["@type"]==="General"));if(generalTrack&&generalTrack.Duration){return parseFloat(generalTrack.Duration)}}throw new Error("Couldn't extract duration from MediaInfo result")}catch(error){console.warn("MediaInfo failed, falling back to estimation:",error);return fallbackDurationEstimation(fileData)}}function fallbackDurationEstimation(fileData,fileExt){const fileSizeKB=Math.floor(fileData.length/1024);let durationEstimate;if(fileExt==="mp3"){durationEstimate=fileSizeKB*8/128}else if(fileExt==="wav"){durationEstimate=fileSizeKB*8/(16*2*44.1)}else if(fileExt==="flac"){durationEstimate=fileSizeKB*8/500}else if(fileExt==="ogg"){durationEstimate=fileSizeKB*8/96}else{durationEstimate=240}return durationEstimate}function getFFmpegArgs(format){const preset=CONVERSION_PRESETS[format];switch(format){case"audio/mp3":return["-codec:a","libmp3lame","-b:a",`${preset.bitrate}k`,"-joint_stereo","1","-q:a","5","-compression_level","9","-cutoff","18000","-f","mp3"];case"audio/ogg":return["-codec:a","libvorbis","-qscale:a",preset.quality.toString(),"-compression_level","10","-f","ogg"];default:return["-f",format.split("/")[1]]}}async function basicCompression(file){uploadManager.updateProgress(file,10,"Starting basic compression...");try{const audioContext=new(window.AudioContext||window.webkitAudioContext);const buffer=await file.arrayBuffer();uploadManager.updateProgress(file,30,"Decoding audio...");const audioData=await audioContext.decodeAudioData(buffer);const offlineCtx=new OfflineAudioContext(audioData.numberOfChannels,audioData.length*.7,audioData.sampleRate*.8);const source=offlineCtx.createBufferSource();source.buffer=audioData;source.connect(offlineCtx.destination);source.start();uploadManager.updateProgress(file,60,"Processing audio...");const compressedBuffer=await offlineCtx.startRendering();uploadManager.updateProgress(file,80,"Encoding result...");const blob=await audioBufferToWav(compressedBuffer);return new File([blob],file.name,{type:"audio/wav"})}catch(error){uploadManager.updateProgress(file,0,"Basic compression failed");throw error}}function audioBufferToWav(buffer){return new Promise((resolve=>{const numChannels=buffer.numberOfChannels;const length=buffer.length*numChannels*2;const wavBuffer=new ArrayBuffer(44+length);const view=new DataView(wavBuffer);writeString(view,0,"RIFF");view.setUint32(4,36+length,true);writeString(view,8,"WAVE");writeString(view,12,"fmt ");view.setUint32(16,16,true);view.setUint16(20,1,true);view.setUint16(22,numChannels,true);view.setUint32(24,buffer.sampleRate,true);view.setUint32(28,buffer.sampleRate*2*numChannels,true);view.setUint16(32,numChannels*2,true);view.setUint16(34,16,true);writeString(view,36,"data");view.setUint32(40,length,true);let offset=44;for(let i=0;i<buffer.numberOfChannels;i++){const channel=buffer.getChannelData(i);for(let j=0;j<channel.length;j++){const sample=Math.max(-1,Math.min(1,channel[j]));view.setInt16(offset,sample<0?sample*32768:sample*32767,true);offset+=2}}resolve(new Blob([view],{type:"audio/wav"}))}))}function writeString(view,offset,string){for(let i=0;i<string.length;i++){view.setUint8(offset+i,string.charCodeAt(i))}}async function uploadToDB(file,originalFile=null){const isProcessed=originalFile!==null&&file!==originalFile;const updateProgress=percent=>uploadManager.updateProgress(file,50+percent/2,percent<100?"Uploading...":"Upload complete");updateProgress(0);try{const chunkSize=2*1024*1024;let fileData;if(file.size>chunkSize){const totalChunks=Math.ceil(file.size/chunkSize);const chunks=[];for(let i=0;i<totalChunks;i++){const start=i*chunkSize;const end=Math.min(start+chunkSize,file.size);const chunk=file.slice(start,end);const chunkData=await readFileAsArrayBuffer(chunk);chunks.push(chunkData);updateProgress(i/totalChunks*50)}updateProgress(50,"Preparing data...");fileData=await combineArrayBuffers(chunks)}else{fileData=await readFileAsArrayBuffer(file);updateProgress(40)}updateProgress(75,"Saving to database...");const db=await getDB();await new Promise(((resolve,reject)=>{const tx=db.transaction("items","readwrite");tx.onabort=()=>reject(new Error("Transaction was aborted"));tx.onerror=()=>reject(tx.error||new Error("Transaction failed"));const store=tx.objectStore("items");const request=store.add({name:file.name.replace(/\.[^/.]+$/,""),data:fileData,type:"user",timestamp:Date.now(),processed:isProcessed,originalSize:originalFile?originalFile.size:file.size,finalSize:file.size});request.onsuccess=()=>{updateProgress(100);resolve()};request.onerror=()=>reject(request.error)}))}catch(error){console.error("Upload error:",error);throw error}}function readFileAsArrayBuffer(file){return new Promise(((resolve,reject)=>{const reader=new FileReader;reader.onload=()=>resolve(reader.result);reader.onerror=()=>reject(reader.error);reader.readAsArrayBuffer(file)}))}function combineArrayBuffers(buffers){const totalLength=buffers.reduce(((sum,buffer)=>sum+buffer.byteLength),0);const result=new Uint8Array(totalLength);let offset=0;for(const buffer of buffers){result.set(new Uint8Array(buffer),offset);offset+=buffer.byteLength}return result.buffer}function formatFileSize(bytes){const sizes=["Bytes","KB","MB","GB"];if(bytes===0)return"0 Bytes";const i=Math.floor(Math.log(bytes)/Math.log(1024));return parseFloat((bytes/Math.pow(1024,i)).toFixed(2))+" "+sizes[i]}function togglePlaylistVisibility(){state.isPlaylistVisible=!state.isPlaylistVisible;elements.playlistSection.classList.toggle("visible",state.isPlaylistVisible);if(window.matchMedia("(max-width: 767px) and (orientation: portrait)").matches){elements.playlistSection.style.display="block";void elements.playlistSection.offsetHeight}saveState();const message=state.isPlaylistVisible?"Playlist shown":"Playlist hidden";showStatusMessage(message);if(state.speechEnabled)speakText(message)}function toggleSelection(index){if(state.selectedItems.has(index)){state.selectedItems.delete(index)}else{state.selectedItems.add(index)}renderPlayList()}function playItem(index){clearSelections();loadItem(index);state.selectedItems.add(index);renderPlayList()}function clearSelections(){state.selectedItems.clear();renderPlayList()}function handleSelectAll(){state.selectedItems=new Set([...Array(state.items.length).keys()]);renderPlayList()}async function handleDeleteSelected(){if(state.selectedItems.size===0){showStatusMessage("No items selected to delete","info");return}try{const database=await getDB();const tx=database.transaction("items","readwrite");const store=tx.objectStore("items");const indicesToDelete=Array.from(state.selectedItems);const itemsToDelete=indicesToDelete.map((index=>state.items[index]));const deletingDefaults=itemsToDelete.some((item=>item.type==="default"));if(deletingDefaults){state.defaultsDeleted=true;saveState()}let deletedCount=0;for(const item of itemsToDelete){const req=store.delete(item.id);req.onsuccess=()=>deletedCount++}await new Promise(((resolve,reject)=>{tx.oncomplete=resolve;tx.onerror=()=>reject(tx.error);tx.onabort=()=>reject(new Error("Transaction aborted"))}));state.selectedItems.clear();localStorage.setItem("defaultsDeleted","true");if(indicesToDelete.length===state.items.length){state.items=[];renderPlayList();state.audio.pause();state.audio.src="";elements.playPauseBtn.textContent="▶";showStatusMessage("All items deleted. Playlist empty.","info")}else{await loadItems(false);showStatusMessage(`${deletedCount} item(s) deleted`,"success")}}catch(error){console.error("Delete failed:",error);showStatusMessage("Error deleting items","error")}}export{loadItems,uploadManager,handleFileUpload,togglePlaylistVisibility,toggleSelection,playItem,clearSelections,handleSelectAll,handleDeleteSelected};